/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  // If you are using a different version of Java, change this.
  JDK_VERSION = "1.8";
  static = false;
}

/**
 * This defines the main class that is generated by the parser generator.  We've
 * added a main method to the code that will be generated.
**/
PARSER_BEGIN(Compiler)
package compiler;
import java.util.HashMap;

public class Compiler
{
  // Maps programming language variables to DC registers
  private HashMap < String, Character > variables =
        new HashMap < String, Character > ();

  // Maps programming language variables to types.
  private HashMap<String, String > types =
        new HashMap<String, String >();

  // If the type is not "int", throws a TypeException
  public void checkInt (String type)
  {
    if (!(type.equals("int")))
    {
      throw new TypeException("Expected int, received " + type);
    }
  }
  
  public static void main(String args [])
  {
    Compiler compiler = new Compiler(System.in);
    try
    {
      compiler.program();
    }
    catch (TypeException e)
    {
      System.err.println(e.getMessage());
    }
    catch (ParseException e)
    {
      System.err.println("Parse error: " + e.getMessage());
    }
    catch (TokenMgrError e)
    {
      System.err.println(e.getMessage());
    }
    catch (RuntimeException e)
    {
      System.err.println(e.getMessage());
    }
  }
}

/**
 * Exception used to report type-checking errors.
 */
 class TypeException extends RuntimeException
 {
   public TypeException (String message)
   {
     super(message);
   }
 }

PARSER_END(Compiler)

/************************ Regular expressions that define tokens ***********************/
SKIP : /* Whitespace to be ignored */
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Operators */
{
  < ASSIGN : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < EQUALTO : "==" >
| < NOT : "!" >
}

TOKEN : /* Keywords and punctuation */
{
  < INTTYPE : "int" >
| < STRINGTYPE : "string" >
| < BOOLEANTYPE : "boolean" >
| < PRINT : "print" >
| < NEWLINE : "newline" >
| < READ : "read" >
| < SEMI: ";" >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < IF: "if" >
| < ELSE: "else" >
| < OPENBRACE: "{" >
| < CLOSEBRACE: "}" >
}

TOKEN : /* Constants, variables, strings */
{
  < CONSTANT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < BOOLEAN : "true" | "false" >
| < VAR : (< LETTER >)+ >
| < #LETTER : [ "a"-"z" ] | [ "A"-"Z" ] >
| < STRING: "\"" (~["\"", "[", "]"])* "\"" >
}

/***************************** Productions that define grammar *******************/
void program() :
{
}
{
  ( statement() )* < EOF >
}

void statement() :
{
  Token t;
  Token vtype;
  String etype;
}
{
    t = < VAR > < ASSIGN > etype = exp() < SEMI >
    {
      if (types.get(t.image) == null)
      {
          throw new TypeException("Undeclared variable: " + t.image);
      }
      if (!types.get(t.image).equals(etype))
	  {
		  throw new TypeException("Type mismatch: " + types.get(t.image) + "=" + etype);
      }		
      char reg = variables.get(t.image);
      System.out.print("s" + reg + " ");
    }
|
    ( vtype = < INTTYPE > | vtype = < STRINGTYPE > | vtype = < BOOLEANTYPE > ) t = < VAR > < ASSIGN > etype = exp() < SEMI >
    {
      if (types.get(t.image) == null)
      {
        if (variables.size() >= 26)
        {
          throw new TypeException("Too many variables; limit is 26");
        }
        variables.put(t.image, (char) ('A' + variables.size()));
		types.put(t.image, vtype.image);

		if (!vtype.image.equals(etype))
		{
		  throw new TypeException("Type mismatch: " + vtype.image + "=" + etype);
		}
		
		char reg2 = variables.get(t.image);
        System.out.print("s" + reg2 + " ");
      }
      else
      {
        throw new TypeException("Variable already declared: " + t.image);
      }
    }
|   
    < PRINT > etype = exp() < SEMI >
    {
      if (etype.equals("boolean"))
      {
        System.out.println("sa [true] la 0 [sa [false]] sa =a n ");		/*TODO: was println*/
      }
      else
      {
        System.out.println("n ");		/*TODO: was println*/
      }
    }
|
  	< NEWLINE > < SEMI >
  	{
  	  System.out.print("[] p ");
  	}
|
  	< READ > t = < VAR > < SEMI >
	{
      if (types.get(t.image) == null)
      {
          throw new TypeException("Undeclared variable: " + t.image);
      }
      if (!types.get(t.image).equals("int"))
	  {
		  throw new TypeException("Type mismatch, need a int variable.");
      }
      char reg3 = variables.get(t.image);
      System.out.print("? " + "s" + reg3 + " ");
	}
|
  < IF > < LPAREN > etype = exp() < RPAREN >
  {
    if (!etype.equals("boolean"))
	{
	  throw new TypeException("Type mismatch: " + "if (" + etype + ")");
	}
	System.out.print("[");
  }
  block() < ELSE >
  {
    System.out.print("] r 0 [s");
    if (variables.size() >= 26)
    {
      throw new TypeException("Too many variables; limit is 26");
    }
    char lastR = (char)('A' + variables.size());
    System.out.print(lastR + " [");
  }
  block()
  {
    System.out.print("]] s" + lastR + " =" + lastR + " x");
  }
}

void block() :
{
}
{
  < OPENBRACE >
  (
    statement()
  )*
  < CLOSEBRACE >
}

String exp() :
{
  Token t;
  String type1, type2;
}
{
  type1 = greatOrLessExp()
  (
    t = < EQUALTO > type2 = greatOrLessExp()
    {
      if (!type1.equals(type2))
	  {
		  throw new TypeException("Type mismatch: " + type1 + t.image + type2);
      }
      if (variables.size() >= 26)
      {
        throw new TypeException("Too many variables; limit is 26");
      }
      char lastR = (char)('A' + variables.size());
      System.out.print("s" + lastR + " 0 r l" + lastR + " [s" + lastR + " 1] s" + lastR + " =" + lastR + " ");
      type1 = "boolean";
    }
  )*
  {
    return type1;
  }
}

String greatOrLessExp() :
{
  Token t;
  String type1, type2;
}
{
  type1 = arithematicExp()
  (
    (t = < LESSTHAN > | t = < GREATERTHAN >) type2 = arithematicExp()
    {
      checkInt(type1);
      checkInt(type2);
      if (variables.size() >= 26)
      {
        throw new TypeException("Too many variables; limit is 26");
      }
      char lastR = (char)('A' + variables.size());
      System.out.print("s" + lastR + " 0 r l" + lastR + " [s" + lastR + " 1] s" + lastR);
	  if (t.image.equals(">"))
	  	 { System.out.print(" <" + lastR + " "); }
	  else
	  	 { System.out.print(" >" + lastR + " "); }
      type1 = "boolean";
    }
  )*
  {
    return type1;
  }
}

String arithematicExp() :
{
  Token t;
  String type1, type2;
}
{
  type1 = term()
  (
    ( t = < PLUS > | t = < MINUS > ) type2 = term()
    {
      System.out.print(t.image + " ");
      checkInt(type1);
	  checkInt(type2);
    }
  )*
  {
    return type1;
  }
}

String term() :
{
  Token t;
  String type1, type2;
}
{
  type1 = factor()
  (
    ( t = < MULTIPLY > | t = < DIVIDE > )
    type2 = factor()
    {
      System.out.print(t.image + " ");
      checkInt(type1);
      checkInt(type2);
    }
  )*
  {
    return type1;
  }
}

String factor() :
{
  String type;
}
{
  < MINUS > type = element()
  {
    checkInt(type);
    System.out.print("_1 * ");
    return "int";
  }
|
  type = element()
  {
	return type;
  }
}

String element() :
{
  Token t;
  String type;
}
{
  t = < CONSTANT >
  {
    System.out.print(t.image + " ");
    return "int";
  }
|
  t = < STRING >
  {
    String dcs = t.image.replaceFirst("\"", "[");
    dcs = dcs.replaceFirst("\"", "]");
	System.out.print(dcs + " ");
	return "string";
  }
|  
  t = < VAR >
  {
    if (types.get(t.image) == null)
    {
		throw new TypeException("Undefined variable " + t.image);
    }
    Character reg = variables.get(t.image);
    System.out.print("l" + reg + " ");
    return types.get(t.image);
  }
|
  < LPAREN > type = exp() < RPAREN >
  {
	return type;
  }
|
  t = < BOOLEAN >
  {
    if (t.image.equals("false"))
    	System.out.print("0 ");
    else
    	System.out.print("1 ");
    return "boolean";
  }
|
	< NOT > type = element()
	{
		if (!type.equals("boolean"))
		{
		  throw new TypeException("Type mismatch: " + "!" + type);
		}
		System.out.print("1-2^");
		return "boolean";
	}
}