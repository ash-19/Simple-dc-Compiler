/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  // If you are using a different version of Java, change this.
  JDK_VERSION = "1.8";
  static = false;
}

/**
 * This defines the main class that is generated by the parser generator.  We've
 * added a main method to the code that will be generated.
**/
PARSER_BEGIN(Parser)
package parser;

public class Parser
{
  public static void main(String args [])
  {
    Parser parser = new Parser(System.in);
    try
    {
      parser.program();
    }
    catch (ParseException e)
    {
      System.err.println("Parse error: " + e.getMessage());
    }
    catch (TokenMgrError e)
    {
      System.err.println(e.getMessage());
    }
    catch (RuntimeException e)
    {
      System.err.println(e.getMessage());
    }
  }
}
PARSER_END(Parser)

/************************ Regular expressions that define tokens ***********************/
SKIP : /* Whitespace to be ignored */
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Operators */
{
  < ASSIGN : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < EQUALTO : "==" >
| < NOT : "!" >
}

TOKEN : /* Keywords and punctuation */
{
  < INTTYPE : "int" >
| < STRINGTYPE : "string" >
| < BOOLEANTYPE : "boolean" >
| < PRINT : "print" >
| < NEWLINE : "newline" >
| < READ : "read" >
| < SEMI: ";" >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < IF: "if" >
| < ELSE: "else" >
| < OPENBRACE: "{" >
| < CLOSEBRACE: "}" >
}

TOKEN : /* Constants, variables, strings */
{
  < CONSTANT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < BOOLEAN : "true" | "false" >
| < VAR : (< LETTER >)+ >
| < #LETTER : [ "a"-"z" ] | [ "A"-"Z" ] >
| < STRING: "\"" (~["\"", "[", "]"])* "\"" >
}


/***************************** Productions that define grammar *******************/
void program() :
{
}
{
  ( statement() )* < EOF >
}

void statement() :
{
}
{
  < VAR > < ASSIGN > exp() < SEMI >
|
  ( < INTTYPE > | < STRINGTYPE > | < BOOLEANTYPE > ) < VAR > < ASSIGN > exp() < SEMI >
|   
  < PRINT > exp() < SEMI >
|
  < NEWLINE > < SEMI >
|
  < READ > < VAR > < SEMI >
|
  < IF > < LPAREN > exp() < RPAREN > block() < ELSE > block()
}

void block() :
{
}
{
  < OPENBRACE >
  (
    statement()
  )*
  < CLOSEBRACE >
}

void exp() :
{
}
{
  greatOrLessExp()
  (
    < EQUALTO > greatOrLessExp()
  )*
}

void greatOrLessExp() :
{
}
{
  arithematicExp()
  (
    (< LESSTHAN > | < GREATERTHAN >) arithematicExp()
  )*
}

void arithematicExp() :
{
}
{
  term()
  (
    ( < PLUS > | < MINUS > ) term()
  )*
}

void term() :
{
}
{
  factor()
  (
    ( < MULTIPLY > | < DIVIDE > ) factor()    
  )*
}

void factor() :
{
}
{
  < MINUS > element()
|
  element()
}

void element() :
{
}
{
  < CONSTANT >
|
  < STRING >
|  
  < VAR >
|
  < LPAREN > exp() < RPAREN >
|
  < BOOLEAN >
|
  < NOT > element()
}
